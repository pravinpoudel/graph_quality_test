{"version":3,"sources":["greadbility.js"],"names":["greadability","nodes","links","id","getSumOfArray","numArray","i","graphStats","length","crossing","n","sum","crossingAngle","m","cMax","dMax","degree","Array","idealAngle","direction","pj","pk","source","index","pi","splice","p1","p2","onSegment","link","Math","max","push","target","linksCross","link1","link2","line1","line2","d1","d2","d3","d4","linesCross","x","y","linkCrossings","j","linesegmentsAngle","len","angle1","angle2","sLine1","sLine2","temp","hypot","acos","acuteLinesAngle","PI","slope1","slope2","abs","angle","angularRes","resMin","incident","line0","nextLink","b","atan","angleB","angularResolutionDev","nodeById","filter","l","d","initialize","_typeof","filteredLinks","forEach","s","t","sort","a","map","crossInfo","c","angularResInfo","incidentLinkAngles","nonZeroDeg","node","minAngle","resDev","angleA","min","apply","idealMinAngle","angularResolutionMin"],"mappings":"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","file":"greadbility.min.js","sourcesContent":["export let greadability = function (nodes, links, id) {\r\n    var i,\r\n      j,\r\n      n = nodes.length,\r\n      m,\r\n      degree = new Array(nodes.length),\r\n      cMax,\r\n      idealAngle = 70,\r\n      dMax;\r\n  \r\n    /*\r\n     * Tracks the global graph readability metrics.\r\n     */\r\n    var graphStats = {\r\n      crossing: 0, // Normalized link crossings\r\n      crossingAngle: 0, // Normalized average dev from 70 deg\r\n      angularResolutionMin: 0, // Normalized avg dev from ideal min angle\r\n      angularResolutionDev: 0, // Normalized avg dev from each link\r\n    };\r\n  \r\n    var getSumOfArray = function (numArray) {\r\n      var i = 0,\r\n        n = numArray.length,\r\n        sum = 0;\r\n      for (; i < n; ++i) sum += numArray[i];\r\n      return sum;\r\n    };\r\n  \r\n    var initialize = function () {\r\n      var i, j, link;\r\n      var nodeById = {};\r\n      // Filter out self loops\r\n      links = links.filter(function (l) {\r\n        return l.source !== l.target;\r\n      });\r\n  \r\n      m = links.length;\r\n  \r\n      if (!id) {\r\n        id = function (d) {\r\n          return d.index;\r\n        };\r\n      }\r\n  \r\n      for (i = 0; i < n; ++i) {\r\n        nodes[i].index = i;\r\n        degree[i] = [];\r\n        nodeById[id(nodes[i], i, nodeById)] = nodes[i];\r\n      }\r\n  \r\n      // Make sure source and target are nodes and not indices.\r\n      for (i = 0; i < m; ++i) {\r\n        link = links[i];\r\n        if (typeof link.source !== \"object\") link.source = nodeById[link.source];\r\n        if (typeof link.target !== \"object\") link.target = nodeById[link.target];\r\n      }\r\n  \r\n      // Filter out duplicate links\r\n      var filteredLinks = [];\r\n      links.forEach(function (l) {\r\n        var s = l.source,\r\n          t = l.target;\r\n        if (s.index > t.index) {\r\n          filteredLinks.push({ source: t, target: s });\r\n        } else {\r\n          filteredLinks.push({ source: s, target: t });\r\n        }\r\n      });\r\n      links = filteredLinks;\r\n      links.sort(function (a, b) {\r\n        if (a.source.index < b.source.index) return -1;\r\n        if (a.source.index > b.source.index) return 1;\r\n        if (a.target.index < b.target.index) return -1;\r\n        if (a.target.index > b.target.index) return 1;\r\n        return 0;\r\n      });\r\n      i = 1;\r\n      while (i < links.length) {\r\n        if (\r\n          links[i - 1].source.index === links[i].source.index &&\r\n          links[i - 1].target.index === links[i].target.index\r\n        ) {\r\n          links.splice(i, 1);\r\n        } else ++i;\r\n      }\r\n  \r\n      // Update length, if a duplicate was deleted.\r\n      m = links.length;\r\n  \r\n      // Calculate degree.\r\n      for (i = 0; i < m; ++i) {\r\n        link = links[i];\r\n        link.index = i;\r\n  \r\n        degree[link.source.index].push(link);\r\n        degree[link.target.index].push(link);\r\n      }\r\n    };\r\n  \r\n    // Assume node.x and node.y are the coordinates\r\n  \r\n    function direction(pi, pj, pk) {\r\n      var p1 = [pk[0] - pi[0], pk[1] - pi[1]];\r\n      var p2 = [pj[0] - pi[0], pj[1] - pi[1]];\r\n      return p1[0] * p2[1] - p2[0] * p1[1];\r\n    }\r\n  \r\n    // Is point k on the line segment formed by points i and j?\r\n    // Inclusive, so if pk == pi or pk == pj then return true.\r\n    function onSegment(pi, pj, pk) {\r\n      return (\r\n        Math.min(pi[0], pj[0]) <= pk[0] &&\r\n        pk[0] <= Math.max(pi[0], pj[0]) &&\r\n        Math.min(pi[1], pj[1]) <= pk[1] &&\r\n        pk[1] <= Math.max(pi[1], pj[1])\r\n      );\r\n    }\r\n  \r\n    function linesCross(line1, line2) {\r\n      var d1, d2, d3, d4;\r\n  \r\n      // CLRS 2nd ed. pg. 937\r\n      d1 = direction(line2[0], line2[1], line1[0]);\r\n      d2 = direction(line2[0], line2[1], line1[1]);\r\n      d3 = direction(line1[0], line1[1], line2[0]);\r\n      d4 = direction(line1[0], line1[1], line2[1]);\r\n  \r\n      if (\r\n        ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\r\n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))\r\n      ) {\r\n        return true;\r\n      } else if (d1 === 0 && onSegment(line2[0], line2[1], line1[0])) {\r\n        return true;\r\n      } else if (d2 === 0 && onSegment(line2[0], line2[1], line1[1])) {\r\n        return true;\r\n      } else if (d3 === 0 && onSegment(line1[0], line1[1], line2[0])) {\r\n        return true;\r\n      } else if (d4 === 0 && onSegment(line1[0], line1[1], line2[1])) {\r\n        return true;\r\n      }\r\n  \r\n      return false;\r\n    }\r\n  \r\n    function linksCross(link1, link2) {\r\n      // Self loops are not intersections\r\n      if (\r\n        link1.index === link2.index ||\r\n        link1.source === link1.target ||\r\n        link2.source === link2.target\r\n      ) {\r\n        return false;\r\n      }\r\n  \r\n      // Links cannot intersect if they share a node\r\n      if (\r\n        link1.source === link2.source ||\r\n        link1.source === link2.target ||\r\n        link1.target === link2.source ||\r\n        link1.target === link2.target\r\n      ) {\r\n        return false;\r\n      }\r\n  \r\n      var line1 = [\r\n        [link1.source.x, link1.source.y],\r\n        [link1.target.x, link1.target.y],\r\n      ];\r\n  \r\n      var line2 = [\r\n        [link2.source.x, link2.source.y],\r\n        [link2.target.x, link2.target.y],\r\n      ];\r\n  \r\n      return linesCross(line1, line2);\r\n    }\r\n  \r\n    function linkCrossings() {\r\n      var i,\r\n        j,\r\n        c = 0,\r\n        d = 0,\r\n        link1,\r\n        link2,\r\n        line1,\r\n        line2;\r\n  \r\n      // Sum the upper diagonal of the edge crossing matrix.\r\n      for (i = 0; i < m; ++i) {\r\n        for (j = i + 1; j < m; ++j) {\r\n          link1 = links[i];\r\n          link2 = links[j];\r\n  \r\n          // Check if link i and link j intersect\r\n          if (linksCross(link1, link2)) {\r\n            line1 = [\r\n              [link1.source.x, link1.source.y],\r\n              [link1.target.x, link1.target.y],\r\n            ];\r\n            line2 = [\r\n              [link2.source.x, link2.source.y],\r\n              [link2.target.x, link2.target.y],\r\n            ];\r\n            ++c;\r\n            d += Math.abs(idealAngle - acuteLinesAngle(line1, line2));\r\n          }\r\n        }\r\n      }\r\n  \r\n      return { c: 2 * c, d: 2 * d };\r\n    }\r\n  \r\n    function linesegmentsAngle(line1, line2) {\r\n      // Finds the (counterclockwise) angle from line segement line1 to\r\n      // line segment line2. Assumes the lines share one end point.\r\n      // If both endpoints are the same, or if both lines have zero\r\n      // length, then return 0 angle.\r\n      // Param order matters:\r\n      // linesegmentsAngle(line1, line2) != linesegmentsAngle(line2, line1)\r\n      var temp, len, angle1, angle2, sLine1, sLine2;\r\n  \r\n      // Re-orient so that line1[0] and line2[0] are the same.\r\n      if (line1[0][0] === line2[1][0] && line1[0][1] === line2[1][1]) {\r\n        temp = line2[1];\r\n        line2[1] = line2[0];\r\n        line2[0] = temp;\r\n      } else if (line1[1][0] === line2[0][0] && line1[1][1] === line2[0][1]) {\r\n        temp = line1[1];\r\n        line1[1] = line1[0];\r\n        line1[0] = temp;\r\n      } else if (line1[1][0] === line2[1][0] && line1[1][1] === line2[1][1]) {\r\n        temp = line1[1];\r\n        line1[1] = line1[0];\r\n        line1[0] = temp;\r\n        temp = line2[1];\r\n        line2[1] = line2[0];\r\n        line2[0] = temp;\r\n      }\r\n  \r\n      // Shift the line so that the first point is at (0,0).\r\n      sLine1 = [\r\n        [line1[0][0] - line1[0][0], line1[0][1] - line1[0][1]],\r\n        [line1[1][0] - line1[0][0], line1[1][1] - line1[0][1]],\r\n      ];\r\n      // Normalize the line length.\r\n      len = Math.hypot(sLine1[1][0], sLine1[1][1]);\r\n      if (len === 0) return 0;\r\n      sLine1[1][0] /= len;\r\n      sLine1[1][1] /= len;\r\n      // If y < 0, angle = acos(x), otherwise angle = 360 - acos(x)\r\n      angle1 = (Math.acos(sLine1[1][0]) * 180) / Math.PI;\r\n      if (sLine1[1][1] < 0) angle1 = 360 - angle1;\r\n  \r\n      // Shift the line so that the first point is at (0,0).\r\n      sLine2 = [\r\n        [line2[0][0] - line2[0][0], line2[0][1] - line2[0][1]],\r\n        [line2[1][0] - line2[0][0], line2[1][1] - line2[0][1]],\r\n      ];\r\n      // Normalize the line length.\r\n      len = Math.hypot(sLine2[1][0], sLine2[1][1]);\r\n      if (len === 0) return 0;\r\n      sLine2[1][0] /= len;\r\n      sLine2[1][1] /= len;\r\n      // If y < 0, angle = acos(x), otherwise angle = 360 - acos(x)\r\n      angle2 = (Math.acos(sLine2[1][0]) * 180) / Math.PI;\r\n      if (sLine2[1][1] < 0) angle2 = 360 - angle2;\r\n  \r\n      return angle1 <= angle2 ? angle2 - angle1 : 360 - (angle1 - angle2);\r\n    }\r\n  \r\n    function acuteLinesAngle(line1, line2) {\r\n      // Acute angle of intersection, in degrees. Assumes these lines\r\n      // intersect.\r\n      var slope1 = (line1[1][1] - line1[0][1]) / (line1[1][0] - line1[0][0]);\r\n      var slope2 = (line2[1][1] - line2[0][1]) / (line2[1][0] - line2[0][0]);\r\n  \r\n      // If these lines are two links incident on the same node, need\r\n      // to check if the angle is 0 or 180.\r\n      if (slope1 === slope2) {\r\n        // If line2 is not on line1 and line1 is not on line2, then\r\n        // the lines share only one point and the angle must be 180.\r\n        if (\r\n          !(\r\n            onSegment(line1[0], line1[1], line2[0]) &&\r\n            onSegment(line1[0], line1[1], line2[1])\r\n          ) ||\r\n          !(\r\n            onSegment(line2[0], line2[1], line1[0]) &&\r\n            onSegment(line2[0], line2[1], line1[1])\r\n          )\r\n        )\r\n          return 180;\r\n        else return 0;\r\n      }\r\n  \r\n      var angle = Math.abs(Math.atan(slope1) - Math.atan(slope2));\r\n  \r\n      return ((angle > Math.PI / 2 ? Math.PI - angle : angle) * 180) / Math.PI;\r\n    }\r\n  \r\n    function angularRes() {\r\n      var j,\r\n        resMin = 0,\r\n        resDev = 0,\r\n        nonZeroDeg,\r\n        node,\r\n        minAngle,\r\n        idealMinAngle,\r\n        incident,\r\n        line0,\r\n        line1,\r\n        line2,\r\n        incidentLinkAngles,\r\n        nextLink;\r\n  \r\n      nonZeroDeg = degree.filter(function (d) {\r\n        return d.length >= 1;\r\n      }).length;\r\n  \r\n      for (j = 0; j < n; ++j) {\r\n        node = nodes[j];\r\n        line0 = [\r\n          [node.x, node.y],\r\n          [node.x + 1, node.y],\r\n        ];\r\n  \r\n        // Links that are incident to this node (already filtered out self loops)\r\n        incident = degree[j];\r\n  \r\n        if (incident.length <= 1) continue;\r\n  \r\n        idealMinAngle = 360 / incident.length;\r\n  \r\n        // Sort edges by the angle they make from an imaginary vector\r\n        // emerging at angle 0 on the unit circle.\r\n        // Necessary for calculating angles of incident edges correctly\r\n        incident.sort(function (a, b) {\r\n          line1 = [\r\n            [a.source.x, a.source.y],\r\n            [a.target.x, a.target.y],\r\n          ];\r\n          line2 = [\r\n            [b.source.x, b.source.y],\r\n            [b.target.x, b.target.y],\r\n          ];\r\n          var angleA = linesegmentsAngle(line0, line1);\r\n          var angleB = linesegmentsAngle(line0, line2);\r\n          return angleA < angleB ? -1 : angleA > angleB ? 1 : 0;\r\n        });\r\n  \r\n        incidentLinkAngles = incident.map(function (l, i) {\r\n          nextLink = incident[(i + 1) % incident.length];\r\n          line1 = [\r\n            [l.source.x, l.source.y],\r\n            [l.target.x, l.target.y],\r\n          ];\r\n          line2 = [\r\n            [nextLink.source.x, nextLink.source.y],\r\n            [nextLink.target.x, nextLink.target.y],\r\n          ];\r\n          return linesegmentsAngle(line1, line2);\r\n        });\r\n  \r\n        minAngle = Math.min.apply(null, incidentLinkAngles);\r\n  \r\n        resMin += Math.abs(idealMinAngle - minAngle) / idealMinAngle;\r\n  \r\n        resDev +=\r\n          getSumOfArray(\r\n            incidentLinkAngles.map(function (angle) {\r\n              return Math.abs(idealMinAngle - angle) / idealMinAngle;\r\n            })\r\n          ) /\r\n          (2 * incident.length - 2);\r\n      }\r\n  \r\n      // Divide by number of nodes with degree != 0\r\n      resMin = resMin / nonZeroDeg;\r\n  \r\n      // Divide by number of nodes with degree != 0\r\n      resDev = resDev / nonZeroDeg;\r\n  \r\n      return { resMin: resMin, resDev: resDev };\r\n    }\r\n  \r\n    initialize();\r\n  \r\n    cMax =\r\n      (m * (m - 1)) / 2 -\r\n      getSumOfArray(\r\n        degree.map(function (d) {\r\n          return d.length * (d.length - 1);\r\n        })\r\n      ) /\r\n        2;\r\n  \r\n    var crossInfo = linkCrossings();\r\n  \r\n    dMax = crossInfo.c * idealAngle;\r\n  \r\n    graphStats.crossing = 1 - (cMax > 0 ? crossInfo.c / cMax : 0);\r\n  \r\n    graphStats.crossingAngle = 1 - (dMax > 0 ? crossInfo.d / dMax : 0);\r\n  \r\n    var angularResInfo = angularRes();\r\n  \r\n    graphStats.angularResolutionMin = 1 - angularResInfo.resMin;\r\n  \r\n    graphStats.angularResolutionDev = 1 - angularResInfo.resDev;\r\n  \r\n    return graphStats;\r\n  };\r\n  "]}